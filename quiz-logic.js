// This file was auto-generated by extract-pure-functions.js
// Source file: docs/script.js
// Generated at: 2026-01-02T02:43:10.762Z

export const MAX_QUESTIONS = 10;

export const CONFIG = {
    MAX_PRIME_FACTORS: 5,
    PRIME_WEIGHTS: { 2: 25, 3: 25, 5: 8, 7: 12, 11: 3, 13: 2, 17: 1, 19: 1, 23: 1, 29: 1, 31: 1, 37: 1 },
    STOP_PROBABILITY_TABLE: [
        [0, 20],      // 20未満は続ける
        [0.3, 40],    // 20〜40は30%で停止
        [0.7, 60],    // 40〜60は70%で停止
        [0.90, 80],   // 60〜80は90%で停止
        [0.98, 100],  // 80〜100は98%で停止
    ],
    MAX_VALUE: 150,
};

export function getDivisorPairs(n) {
    const pairs = [];
    for (let i = 2; i <= Math.sqrt(n); i++) {
        if (n % i === 0) {
            pairs.push([i, n / i]);
        }
    }
    return pairs;
}

export function selectWeightedPrime(primeWeights) {
    const primes = Object.keys(primeWeights).map(Number);
    const weights = Object.values(primeWeights);
    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let random = Math.random() * totalWeight;
    
    for (let i = 0; i < primes.length; i++) {
        random -= weights[i];
        if (random <= 0) {
            return primes[i];
        }
    }
    return primes[0];
}

export function getStopProbability(value, stopProbabilityTable) {
    const entry = stopProbabilityTable.find(([, threshold]) => value < threshold);
    return entry ? entry[0] : 1.0; // それ以上は100%で停止
}

export function generateAnswerNumber(config = CONFIG) {
    const maxValue = config.MAX_VALUE;
    // 最小素数と最大素数の積がmaxValue以下であることを確認
    // これにより、どの素数からスタートしても少なくとも1つの素数を掛けられることが保証される
    const primes = Object.keys(config.PRIME_WEIGHTS).map(Number);
    const minPrime = Math.min(...primes);
    const maxPrime = Math.max(...primes);
    console.assert(minPrime * maxPrime <= maxValue, `${minPrime} * ${maxPrime} > ${maxValue}`);
    
    let result = selectWeightedPrime(config.PRIME_WEIGHTS);
    const divisors = [result];
    
    while (divisors.length < config.MAX_PRIME_FACTORS) {
        const prime = selectWeightedPrime(config.PRIME_WEIGHTS);
        const newResult = result * prime;
        
        // 上限を超えたら終了
        if (newResult > maxValue) {
            break;
        }
        
        result = newResult;
        divisors.push(result);
        
        // 現在の値に応じて停止するかどうかを判定
        if (Math.random() < getStopProbability(result, config.STOP_PROBABILITY_TABLE)) {
            break;
        }
    }

    if (divisors.length < 2) {
        const prime = [2, 3][Math.floor(Math.random() * 2)];
        result *= prime;
        divisors.push(result);
    }

    return result;
}

export function generateWrongChoices(targetNumber) {
    // 候補となる数値の配列を生成（3以下とtargetNumberは除外）
    const candidates = [];
    for (let offset = -10; offset <= 10; offset++) {
        const nearbyNumber = targetNumber + offset;
        if (nearbyNumber > 3 && nearbyNumber !== targetNumber) {
            candidates.push(nearbyNumber);
        }
    }
    shuffleArray(candidates);
    // targetNumberが奇数の場合、奇数を優先的に選ぶ
    if (targetNumber % 2 === 1) {
        candidates.sort((a, b) => (a % 2 === 0) - (b % 2 === 0));
    }
    
    // 候補から順に約数ペアを取得
    const wrongChoices = [];
    for (const nearbyNumber of candidates) {
        if (wrongChoices.length >= 3) break;
        
        const pairs = getDivisorPairs(nearbyNumber);
        if (pairs.length === 0) continue;
        
        const selectedPair = pairs[Math.floor(Math.random() * pairs.length)];
        wrongChoices.push(selectedPair);
    }
    
    return wrongChoices;
}

export function shuffleArray(array) {
    const shuffled = array
        .map(value => ({ value, rand: Math.random() }))
        .sort((a, b) => a.rand - b.rand);
    for (let i = 0; i < array.length; i++) {
        array[i] = shuffled[i].value;
    }
    return array;
}

